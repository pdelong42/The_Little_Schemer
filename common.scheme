(define notpair? (lambda (x) (not (pair? x))))

(define notatom?
   (lambda
      (x)
      (or
         (pair? x)
         (null? x)
      )
   )
)

(define    atom?    (lambda (x) (not (notatom? x))))

(define notatom?car (lambda (x) (notatom? (car x))))

; repeated here from "peano.scheme"...

(define eq
   (lambda
      (a b)
      (cond
         (  (lt a b) #f)
         (  (gt a b) #f)
         (else #t)
      )
   )
)

(define eqan?
   (lambda
      (a b)
      (cond
         (  (and
               (number? a)
               (number? b)
            )
            (eq a b)
         )
         (  (or
               (number? a)
               (number? b)
            )
            #f
         )
         (else (eq? a b))
      )
   )
)

; this uses (eqlist? ...), which isn't defined yet
; it doesn't fail thanks to lazy evaluation

(define equal?
   (lambda
      (a b)
      (cond
         (  (and
               (pair? a)
               (pair? b)
            )
            (eqlist? a b)
         )
         (  (or
               (pair? a)
               (pair? b)
            )
            #f
         )
         (else (eqan? a b))
      )
   )
)

; an optimized version, pending testing
;
;(define equal?
;   (lambda
;      (a b)
;      (cond
;         (  (eqan? a b) #t)
;         (else (eqlist? a b))
;      )
;   )
;)
